<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="UTF-8" />
  <title>LiDAR Viewer</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }

    canvas {
      display: block;
    }
  </style>
</head>

<body>
  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js';

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 5);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(innerWidth, innerHeight);
    document.body.appendChild(renderer.domElement);

    let pointsMesh;

    function clusterColor(id) {
      const cmap = [
        [1, 0, 0], [0, 1, 0], [0, 0, 1], [1, 1, 0],
        [1, 0, 1], [0, 1, 1], [1, 0.5, 0], [0.5, 0.5, 0.5],
        [0.6, 0.3, 0.9], [0.2, 0.8, 0.3], [0.9, 0.2, 0.5], [0.3, 0.3, 0.9],
        [0.9, 0.6, 0.1], [0.5, 0.9, 0.9], [0.7, 0.1, 0.9], [0.2, 0.2, 0.2]
      ];
      if (id < 0) return [0.3, 0.3, 0.3]; // 노이즈(잡음)은 회색
      return cmap[id % cmap.length];
    }


    async function fetchPoints() {
      try {
        const res = await fetch('/latest');
        const pts = await res.json();

        if (pointsMesh) scene.remove(pointsMesh);

        const pos = new Float32Array(pts.length * 3);
        const col = new Float32Array(pts.length * 3);
        pts.forEach((p, i) => {
          pos[3 * i] = p.x;
          pos[3 * i + 1] = p.y;
          pos[3 * i + 2] = p.z;

          const [r, g, b] = clusterColor(p.cluster_id);
          col[3 * i] = r;
          col[3 * i + 1] = g;
          col[3 * i + 2] = b;
        });

        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.BufferAttribute(pos, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(col, 3));

        const material = new THREE.PointsMaterial({ size: 0.05, vertexColors: true });
        pointsMesh = new THREE.Points(geometry, material);
        scene.add(pointsMesh);
      } catch (err) {
        console.warn('Fetch error:', err);
      }
    }

    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }
    animate();

    // 주기적으로 JSON 요청 (예: 500ms 마다)
    setInterval(fetchPoints, 500);
  </script>
</body>

</html>
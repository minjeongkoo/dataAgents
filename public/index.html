<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>LiDAR 360° Cluster Viewer</title>
  <style>
    body { margin:0; overflow:hidden; }
    canvas { display:block; }
    .label {
      font-family: sans-serif;
      font-size: 12px;
      background: rgba(0, 0, 0, 0.6);
      color: white;
      padding: 2px 4px;
      border-radius: 2px;
      white-space: nowrap;
    }
  </style>

  <!-- importmap 으로 three.js 모듈 경로 지정 -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js"
    }
  }
  </script>
</head>

<body>
<script type="module">
  import * as THREE from 'three';
  import { CSS2DRenderer, CSS2DObject }
    from 'https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/renderers/CSS2DRenderer.js';

  const WS_URL = `ws://${location.host}/ws`;

  // 성능 튜닝: 한 프레임당 최대 표시 포인트 수
  const MAX_DISPLAY_POINTS = 15000;

  let MAX_POINTS = 0;
  let positions  = new Float32Array(0);
  let colors     = new Float32Array(0);

  const clusterColorMap = new Map();
  const prevCenters     = new Map();
  let lastFrameTime     = performance.now();

  // Three.js 기본 세팅
  const scene    = new THREE.Scene();
  const camera   = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
  camera.position.set(0, 0, 5);
  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(innerWidth, innerHeight);
  document.body.appendChild(renderer.domElement);

  // CSS2DRenderer (레이블 표시용)
  const labelRenderer = new CSS2DRenderer();
  labelRenderer.setSize(innerWidth, innerHeight);
  labelRenderer.domElement.style.position = 'absolute';
  labelRenderer.domElement.style.top      = '0';
  document.body.appendChild(labelRenderer.domElement);

  // 버퍼 지오메트리 + 포인트 메쉬
  const geometry = new THREE.BufferGeometry();
  geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  geometry.setAttribute('color',    new THREE.BufferAttribute(colors,    3));
  geometry.setDrawRange(0, 0);
  const material   = new THREE.PointsMaterial({ size:0.03, vertexColors: true });
  const pointsMesh = new THREE.Points(geometry, material);
  scene.add(pointsMesh);

  // 클러스터 박스·레이블·화살표 그룹
  const clusterGroup = new THREE.Group();
  scene.add(clusterGroup);

  // 리사이즈 대응
  window.addEventListener('resize', () => {
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
    labelRenderer.setSize(innerWidth, innerHeight);
  });

  // WebSocket 연결
  const socket = new WebSocket(WS_URL);
  socket.addEventListener('open',  () => console.log('WS connected'));
  socket.addEventListener('close', () => console.log('WS disconnected'));
  socket.addEventListener('message', ({ data }) => {
    const pts = JSON.parse(data);
    const rawCount = pts.length;
    if (rawCount === 0) return;

    // ↓ 다운샘플링 (성능)
    const skip = rawCount > MAX_DISPLAY_POINTS
               ? Math.ceil(rawCount / MAX_DISPLAY_POINTS)
               : 1;
    const count = Math.ceil(rawCount / skip);

    // 버퍼가 모자라면 재할당
    if (count > MAX_POINTS) {
      MAX_POINTS = count;
      positions  = new Float32Array(MAX_POINTS * 3);
      colors     = new Float32Array(MAX_POINTS * 3);
      geometry.setAttribute(
        'position',
        new THREE.BufferAttribute(positions, 3)
          .setUsage(THREE.DynamicDrawUsage)
      );
      geometry.setAttribute(
        'color',
        new THREE.BufferAttribute(colors, 3)
          .setUsage(THREE.DynamicDrawUsage)
      );
    }

    // 클러스터별 pts 수집
    const clusterPtsMap = new Map();
    let di = 0;
    for (let i = 0; i < rawCount; i += skip) {
      const p = pts[i];
      const { x, y, z, cluster_id: cid } = p;

      // 위치
      positions[3*di  ] = x;
      positions[3*di+1] = y;
      positions[3*di+2] = z;

      // 색상 (황금비 기반 해시)
      if (!clusterColorMap.has(cid)) {
        const hue = (cid * 0.618033988749895) % 1;
        clusterColorMap.set(cid, new THREE.Color().setHSL(hue, 0.7, 0.5));
      }
      const c = clusterColorMap.get(cid);
      colors[3*di  ] = c.r;
      colors[3*di+1] = c.g;
      colors[3*di+2] = c.b;

      // 클러스터 맵에 저장
      if (!clusterPtsMap.has(cid)) clusterPtsMap.set(cid, []);
      clusterPtsMap.get(cid).push(new THREE.Vector3(x, y, z));

      di++;
    }

    // 그릴 점 개수 업데이트
    geometry.setDrawRange(0, di);
    geometry.attributes.position.needsUpdate = true;
    geometry.attributes.color.needsUpdate    = true;

    // ── 클러스터 박스/레이블/화살표 갱신 ──
    clusterGroup.clear();
    const now = performance.now();
    const dt  = (now - lastFrameTime)/1000;
    lastFrameTime = now;

    clusterPtsMap.forEach((ptsArr, cid) => {
      // 바운딩 박스
      const box = new THREE.Box3().setFromPoints(ptsArr);
      const helper = new THREE.Box3Helper(box, clusterColorMap.get(cid));
      clusterGroup.add(helper);

      // 중심 & 속도 계산
      const center = box.getCenter(new THREE.Vector3());
      const prev   = prevCenters.get(cid);
      let velocity = new THREE.Vector3(0,0,0),
          speed    = 0;
      if (prev) {
        velocity = center.clone().sub(prev.center).divideScalar(dt);
        speed    = velocity.length();
      }
      prevCenters.set(cid, { center, time: now });

      // 움직임 화살표
      if (speed > 1e-3) {
        const dir = velocity.clone().normalize();
        const arrow = new THREE.ArrowHelper(dir, center, speed*0.5, clusterColorMap.get(cid));
        clusterGroup.add(arrow);
      }

      // 레이블
      const div = document.createElement('div');
      div.className = 'label';
      div.textContent = `ID:${cid} ${speed.toFixed(2)} m/s`;
      const label = new CSS2DObject(div);
      label.position.copy(center);
      clusterGroup.add(label);
    });
  });

  // 애니메이션 루프
  (function animate() {
    requestAnimationFrame(animate);
    renderer.render(scene, camera);
    labelRenderer.render(scene, camera);
  })();
</script>
</body>
</html>

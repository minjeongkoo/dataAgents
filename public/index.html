<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <title>LiDAR Viewer with Layer Colors & Free View</title>
  <style>
    body { margin:0; overflow:hidden; background:#000; }
    canvas { display:block; }
    #logContainer {
      position: fixed;
      top: 10px;
      right: 10px;
      width: 300px;
      max-height: 400px;
      background: rgba(0, 0, 0, 0.7);
      color: #fff;
      padding: 10px;
      font-family: monospace;
      font-size: 12px;
      overflow-y: auto;
      border-radius: 5px;
      z-index: 1000;
    }
    .log-entry {
      margin: 5px 0;
      padding: 5px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }
    .log-entry:last-child {
      border-bottom: none;
    }
  </style>
</head>
<body>
  <div id="logContainer"></div>
  <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.152.2/build/three.module.js",
        "three/examples/jsm/controls/OrbitControls": "https://unpkg.com/three@0.152.2/examples/jsm/controls/OrbitControls.js"
      }
    }
  </script>
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';

    // 로그 컨테이너 참조
    const logContainer = document.getElementById('logContainer');
    const MAX_LOG_ENTRIES = 50; // 최대 로그 항목 수

    // 로그 추가 함수
    function addLog(message) {
      const entry = document.createElement('div');
      entry.className = 'log-entry';
      entry.textContent = message;
      logContainer.insertBefore(entry, logContainer.firstChild);
      
      // 최대 로그 항목 수를 초과하면 오래된 항목 제거
      while (logContainer.children.length > MAX_LOG_ENTRIES) {
        logContainer.removeChild(logContainer.lastChild);
      }
    }

    // 1) Scene / Camera / Renderer
    const scene    = new THREE.Scene();
    const camera   = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 100);
    camera.position.set(0, 0, 5);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(innerWidth, innerHeight);
    document.body.appendChild(renderer.domElement);

    // 2) OrbitControls (마우스 드래그로 자유 시점)
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // 3) 포인트 클라우드용 버퍼: position + color
    const MAX_POINTS = 1000000;
    const positions  = new Float32Array(MAX_POINTS * 3);
    const colors     = new Float32Array(MAX_POINTS * 3);
    const geometry   = new THREE.BufferGeometry();
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color',    new THREE.BufferAttribute(colors,    3));
    const material = new THREE.PointsMaterial({ size: 0.02, vertexColors: true });
    const pointCloud = new THREE.Points(geometry, material);
    scene.add(pointCloud);

    const colorTmp = new THREE.Color();
    let currentPointCount = 0;

    // 4) 360° 완주용 세그먼트 누적
    const SEGMENTS_PER_FRAME = 6;
    let segmentCount  = 0;
    let framePoints   = [];

    // 5) WebSocket 연결
    const ws = new WebSocket(`ws://${location.host}`);
    ws.onopen    = () => {
      console.log('WS opened');
      addLog('WebSocket Connected');
    };
    ws.onerror   = e => {
      console.error('WS error', e);
      addLog('WebSocket Error');
    };

    // 7) 렌더 루프 & 리사이즈
    const RENDER_INTERVAL = 500; // 500ms 간격으로 렌더링 (2 FPS)
    let lastRenderTime = 0;
    let isRendering = false;

    function render() {
      if (!isRendering) return;
      
      const currentTime = performance.now();
      if (currentTime - lastRenderTime >= RENDER_INTERVAL) {
        controls.update();
        renderer.render(scene, camera);
        lastRenderTime = currentTime;
      }
      requestAnimationFrame(render);
    }

    // 렌더링 시작/중지 컨트롤
    function startRendering() {
      if (!isRendering) {
        isRendering = true;
        lastRenderTime = performance.now();
        render();
      }
    }

    function stopRendering() {
      isRendering = false;
    }

    // 초기 렌더링 시작
    startRendering();

    // 리사이즈 이벤트
    window.addEventListener('resize', () => {
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    // WebSocket 메시지 처리 시 렌더링 재시작
    ws.onmessage = ({ data }) => {
      const pts = JSON.parse(data);
      framePoints.push(...pts);
      segmentCount++;
      
      // 데이터 로그 추가
      const avgX = pts.reduce((sum, p) => sum + p.x, 0) / pts.length;
      const avgY = pts.reduce((sum, p) => sum + p.y, 0) / pts.length;
      const avgZ = pts.reduce((sum, p) => sum + p.z, 0) / pts.length;
      
      addLog(`Points: ${pts.length}, Segment: ${segmentCount}/${SEGMENTS_PER_FRAME}`);
      addLog(`Avg Position: X:${avgX.toFixed(2)} Y:${avgY.toFixed(2)} Z:${avgZ.toFixed(2)}`);
      
      if (segmentCount >= SEGMENTS_PER_FRAME) {
        updatePointCloud(framePoints);
        framePoints = [];
        segmentCount = 0;
        startRendering();
        addLog(`Point Cloud Updated: ${currentPointCount} points`);
      }
    };

    // 6) 포인트 클라우드 업데이트
    function updatePointCloud(arr) {
      const maxLayer = arr.reduce((m,p) => p.layer > m ? p.layer : m, 0);
      const layerCount = maxLayer + 1;
      const len = Math.min(arr.length, MAX_POINTS);
      currentPointCount = len;

      // Calculate bounds
      let minX = Infinity, maxX = -Infinity;
      let minY = Infinity, maxY = -Infinity;
      let minZ = Infinity, maxZ = -Infinity;

      for (let i = 0; i < len; i++) {
        const p = arr[i];
        positions[i*3]   = p.x;
        positions[i*3+1] = p.y;
        positions[i*3+2] = p.z;

        // Update bounds
        minX = Math.min(minX, p.x);
        maxX = Math.max(maxX, p.x);
        minY = Math.min(minY, p.y);
        maxY = Math.max(maxY, p.y);
        minZ = Math.min(minZ, p.z);
        maxZ = Math.max(maxZ, p.z);

        // 레이어별 HSL → RGB 매핑
        const h = layerCount>1 ? p.layer / (layerCount - 1) : 0;
        colorTmp.setHSL(h, 1.0, 0.5);
        colors[i*3]   = colorTmp.r;
        colors[i*3+1] = colorTmp.g;
        colors[i*3+2] = colorTmp.b;
      }

      // Log bounds information
      addLog(`Bounds: X[${minX.toFixed(2)}, ${maxX.toFixed(2)}] Y[${minY.toFixed(2)}, ${maxY.toFixed(2)}] Z[${minZ.toFixed(2)}, ${maxZ.toFixed(2)}]`);

      // 사용되지 않는 버퍼 공간을 0으로 채우기
      for (let i = len; i < MAX_POINTS; i++) {
        positions[i*3] = positions[i*3+1] = positions[i*3+2] = 0;
        colors[i*3] = colors[i*3+1] = colors[i*3+2] = 0;
      }

      geometry.setDrawRange(0, len);
      geometry.attributes.position.needsUpdate = true;
      geometry.attributes.color.needsUpdate    = true;
    }
  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <title>LiDAR Viewer with Layer Colors & Free View</title>
  <style>
    body { margin:0; overflow:hidden; background:#000; }
    canvas { display:block; }
  </style>
</head>
<body>
  <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.152.2/build/three.module.js",
        "three/examples/jsm/controls/OrbitControls": "https://unpkg.com/three@0.152.2/examples/jsm/controls/OrbitControls.js"
      }
    }
  </script>
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';

    // 1) Scene / Camera / Renderer
    const scene    = new THREE.Scene();
    const camera   = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 100);
    camera.position.set(0, 0, 5);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(innerWidth, innerHeight);
    document.body.appendChild(renderer.domElement);

    // 2) OrbitControls (마우스 드래그로 자유 시점)
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // 3) 포인트 클라우드용 버퍼: position + color
    const MAX_POINTS = 1000000;
    const positions  = new Float32Array(MAX_POINTS * 3);
    const colors     = new Float32Array(MAX_POINTS * 3);
    const geometry   = new THREE.BufferGeometry();
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color',    new THREE.BufferAttribute(colors,    3));
    const material = new THREE.PointsMaterial({ size: 0.02, vertexColors: true });
    const pointCloud = new THREE.Points(geometry, material);
    scene.add(pointCloud);

    const colorTmp = new THREE.Color();
    let currentPointCount = 0;

    // 4) 360° 완주용 세그먼트 누적
    const SEGMENTS_PER_FRAME = 6;
    let segmentCount  = 0;
    let framePoints   = [];

    // 5) WebSocket 연결
    const ws = new WebSocket(`ws://${location.host}`);
    ws.onopen    = () => console.log('WS opened');
    ws.onerror   = e => console.error('WS error', e);

    // 7) 렌더 루프 & 리사이즈
    const RENDER_INTERVAL = 500; // 500ms 간격으로 렌더링 (2 FPS)
    let lastRenderTime = 0;
    let isRendering = false;

    function render() {
      if (!isRendering) return;
      
      const currentTime = performance.now();
      if (currentTime - lastRenderTime >= RENDER_INTERVAL) {
        controls.update();
        renderer.render(scene, camera);
        lastRenderTime = currentTime;
      }
      requestAnimationFrame(render);
    }

    // 렌더링 시작/중지 컨트롤
    function startRendering() {
      if (!isRendering) {
        isRendering = true;
        lastRenderTime = performance.now();
        render();
      }
    }

    function stopRendering() {
      isRendering = false;
    }

    // 초기 렌더링 시작
    startRendering();

    // 리사이즈 이벤트
    window.addEventListener('resize', () => {
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    // WebSocket 메시지 처리 시 렌더링 재시작
    ws.onmessage = ({ data }) => {
      const pts = JSON.parse(data);
      framePoints.push(...pts);
      segmentCount++;
      if (segmentCount >= SEGMENTS_PER_FRAME) {
        updatePointCloud(framePoints);
        framePoints = [];
        segmentCount = 0;
        startRendering(); // 새로운 데이터가 있을 때 렌더링 재시작
      }
    };

    // 6) 포인트 클라우드 업데이트
    function updatePointCloud(arr) {
      const maxLayer = arr.reduce((m,p) => p.layer > m ? p.layer : m, 0);
      const layerCount = maxLayer + 1;
      const len = Math.min(arr.length, MAX_POINTS);
      currentPointCount = len;

      for (let i = 0; i < len; i++) {
        const p = arr[i];
        positions[i*3]   = p.x;
        positions[i*3+1] = p.y;
        positions[i*3+2] = p.z;

        // 레이어별 HSL → RGB 매핑
        const h = layerCount>1 ? p.layer / (layerCount - 1) : 0;
        colorTmp.setHSL(h, 1.0, 0.5);
        colors[i*3]   = colorTmp.r;
        colors[i*3+1] = colorTmp.g;
        colors[i*3+2] = colorTmp.b;
      }

      // 사용되지 않는 버퍼 공간을 0으로 채우기
      for (let i = len; i < MAX_POINTS; i++) {
        positions[i*3] = positions[i*3+1] = positions[i*3+2] = 0;
        colors[i*3] = colors[i*3+1] = colors[i*3+2] = 0;
      }

      geometry.setDrawRange(0, len);
      geometry.attributes.position.needsUpdate = true;
      geometry.attributes.color.needsUpdate    = true;
    }
  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>LiDAR 360° Cluster Viewer</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    .label { font-family: sans-serif; font-size: 12px; background: rgba(0,0,0,0.6); color: #fff; padding: 2px 4px; border-radius: 2px; white-space: nowrap; }
  </style>
  <script type="importmap">
  { "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js" } }
  </script>
</head>
<body>
  <script type="module">
    import * as THREE from 'three';
    import { CSS2DRenderer, CSS2DObject } from 'https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/renderers/CSS2DRenderer.js';

    const EXPECTED_POINTS = 16 * 270;
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
    camera.position.set(0,0,5);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(innerWidth, innerHeight);
    document.body.appendChild(renderer.domElement);
    const labelRenderer = new CSS2DRenderer();
    labelRenderer.setSize(innerWidth, innerHeight);
    labelRenderer.domElement.style.position = 'absolute';
    labelRenderer.domElement.style.top = '0';
    document.body.appendChild(labelRenderer.domElement);

    let maxPoints = EXPECTED_POINTS;
    let positions = new Float32Array(maxPoints*3);
    let colors    = new Float32Array(maxPoints*3);
    const geometry = new THREE.BufferGeometry();
    geometry.setAttribute('position', new THREE.BufferAttribute(positions,3).setUsage(THREE.DynamicDrawUsage));
    geometry.setAttribute('color',    new THREE.BufferAttribute(colors,3).setUsage(THREE.DynamicDrawUsage));
    geometry.setDrawRange(0,0);
    const material   = new THREE.PointsMaterial({ size:0.03, vertexColors:true });
    const pointsMesh = new THREE.Points(geometry, material);
    scene.add(pointsMesh);
    const boxGroup = new THREE.Group(); scene.add(boxGroup);

    window.addEventListener('resize',()=>{
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
      labelRenderer.setSize(innerWidth, innerHeight);
    });

    const socket = new WebSocket(`ws://${location.host}/ws`);
    let buffer = [];
    socket.addEventListener('message', ({data})=>{
      const pts = JSON.parse(data);
      buffer.push(...pts);
      if(buffer.length < EXPECTED_POINTS) return;
      const frame = buffer.splice(0, EXPECTED_POINTS);

      // 포인트 & 클러스터 렌더링 재사용
      frame.forEach((p,i)=>{
        positions[3*i]   = p.x;
        positions[3*i+1] = p.y;
        positions[3*i+2] = p.z;
        const hue = (p.cluster_id%12)/12;
        const col = new THREE.Color().setHSL(hue,0.8,0.5);
        colors[3*i]   = col.r;
        colors[3*i+1] = col.g;
        colors[3*i+2] = col.b;
      });
      geometry.setDrawRange(0, EXPECTED_POINTS);
      geometry.attributes.position.needsUpdate = true;
      geometry.attributes.color.needsUpdate = true;

      boxGroup.clear();
      const clusters = {};
      frame.forEach(p=>{
        const id=p.cluster_id; if(id<0) return;
        if(!clusters[id]) clusters[id]={min:{...p},max:{...p}};
        ['x','y','z'].forEach(k=>{
          clusters[id].min[k] = Math.min(clusters[id].min[k], p[k]);
          clusters[id].max[k] = Math.max(clusters[id].max[k], p[k]);
        });
      });
      Object.entries(clusters).forEach(([id,box])=>{
        const {min,max} = box;
        const geom  = new THREE.BoxGeometry(max.x-min.x, max.y-min.y, max.z-min.z);
        const edges = new THREE.EdgesGeometry(geom);
        const line  = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({color:0xffffff}));
        line.position.set((min.x+max.x)/2,(min.y+max.y)/2,(min.z+max.z)/2);
        boxGroup.add(line);
        const div   = document.createElement('div');
        div.className='label'; div.textContent = `ID ${id}`;
        const label = new CSS2DObject(div);
        label.position.set((min.x+max.x)/2,(min.y+max.y)/2,max.z);
        boxGroup.add(label);
      });
    });

    (function animate(){
      requestAnimationFrame(animate);
      renderer.render(scene,camera);
      labelRenderer.render(scene,camera);
    })();
  </script>
</body>
</html>

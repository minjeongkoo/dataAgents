<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="UTF-8" />
  <title>LiDAR 360° Cluster Viewer</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }

    canvas {
      display: block;
    }

    .label {
      font-family: sans-serif;
      font-size: 12px;
      background: rgba(0, 0, 0, 0.2);
      color: white;
      width: 120px;
      padding: 2px 4px;
      border-radius: 2px;
      white-space: nowrap;
    }

    #alert {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(255, 0, 0, 0.8);
      color: white;
      padding: 8px 12px;
      border-radius: 4px;
      font-family: sans-serif;
      z-index: 10;
    }
  </style>
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js",
      "three/addons/controls/OrbitControls.js": "https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/controls/OrbitControls.js",
      "three/addons/renderers/CSS2DRenderer.js": "https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/renderers/CSS2DRenderer.js"
    }
  }
  </script>
</head>

<body>
  <div id="alert" style="display:none;"></div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';

    const WS_URL = `ws://${location.host}/ws`;
    const alertBox = document.getElementById("alert");

    let MAX_POINTS = 0;
    let positions = new Float32Array(0);
    let colors = new Float32Array(0);
    const clusterColorMap = new Map();
    const arrows = new Map();
    const boxes = new Map();
    const labels = new Map();

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 5);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(innerWidth, innerHeight);
    document.body.appendChild(renderer.domElement);

    const labelRenderer = new CSS2DRenderer();
    labelRenderer.setSize(innerWidth, innerHeight);
    labelRenderer.domElement.style.position = 'absolute';
    labelRenderer.domElement.style.top = '0px';
    labelRenderer.domElement.style.pointerEvents = 'none';
    document.body.appendChild(labelRenderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.screenSpacePanning = false;
    controls.minDistance = 1;
    controls.maxDistance = 500;

    let geometry = new THREE.BufferGeometry();
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    geometry.setDrawRange(0, 0);
    const material = new THREE.PointsMaterial({ size: 0.03, vertexColors: true });
    const pointsMesh = new THREE.Points(geometry, material);
    scene.add(pointsMesh);

    window.addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
      labelRenderer.setSize(innerWidth, innerHeight);
    });

    const socket = new WebSocket(WS_URL);
    socket.addEventListener('open', () => console.log('WS connected'));
    socket.addEventListener('close', () => console.log('WS disconnected'));
    socket.addEventListener('message', ({ data }) => {
      const { points, clusters } = JSON.parse(data);
      const count = points.length;

      if (count > MAX_POINTS) {
        MAX_POINTS = count;
        positions = new Float32Array(MAX_POINTS * 3);
        colors = new Float32Array(MAX_POINTS * 3);
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3).setUsage(THREE.DynamicDrawUsage));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3).setUsage(THREE.DynamicDrawUsage));
      }

      let dangerDetected = false;
      let dangerText = "";

      for (let i = 0; i < count; i++) {
        const p = points[i];
        positions[3 * i + 0] = p.x;
        positions[3 * i + 1] = p.y;
        positions[3 * i + 2] = p.z;

        const cid = p.cluster_id;
        if (cid === -1) {
          // 회색 점 (noise)
          colors[3 * i + 0] = 0.5;
          colors[3 * i + 1] = 0.5;
          colors[3 * i + 2] = 0.5;
        }
        if (!clusterColorMap.has(cid)) {
          const col = new THREE.Color().setHSL((cid * 0.61803) % 1, 0.7, 0.5);
          clusterColorMap.set(cid, col);
        }
        const col = clusterColorMap.get(cid);
        colors[3 * i + 0] = col.r;
        colors[3 * i + 1] = col.g;
        colors[3 * i + 2] = col.b;
      }

      geometry.setDrawRange(0, count);
      geometry.attributes.position.needsUpdate = true;
      geometry.attributes.color.needsUpdate = true;

      for (const obj of arrows.values()) scene.remove(obj);
      for (const obj of boxes.values()) scene.remove(obj);
      for (const obj of labels.values()) scene.remove(obj);
      arrows.clear();
      boxes.clear();
      labels.clear();

      for (const [cid, info] of Object.entries(clusters)) {
        const origin = new THREE.Vector3(...info.centroid);
        const dir = new THREE.Vector3(...info.velocity);
        const speed = info.speed;

        if (speed > 0.01) {
          const arrow = new THREE.ArrowHelper(dir.clone().normalize(), origin, speed, 0xffff00);
          scene.add(arrow);
          arrows.set(cid, arrow);
        }

        if (cid >= 0) {
          const min = new THREE.Vector3(...info.bbox.min);
          const max = new THREE.Vector3(...info.bbox.max);
          const box = new THREE.Box3(min, max);
          const boxHelper = new THREE.Box3Helper(box, 0xffffff);
          scene.add(boxHelper);
          boxes.set(cid, boxHelper);
        }

        const labelDiv = document.createElement('div');
        labelDiv.className = 'label';
        labelDiv.innerHTML = labelDiv.innerHTML = `ID: ${cid}<br>Count: ${info.count}<br>Speed: ${speed.toFixed(2)}<br>Dir: (${dir.x.toFixed(2)}, ${dir.y.toFixed(2)}, ${dir.z.toFixed(2)})`;;
        const label = new CSS2DObject(labelDiv);
        label.position.copy(origin);
        scene.add(label);
        labels.set(cid, label);

        if (origin.length() < 0.4) {
          console.warn(`Collision risk detected: Cluster ${cid} near (0,0,0)`);
          dangerDetected = true;
          dangerText += `Cluster ${cid} 축률 위험!<br>`;
        }
      }

      if (dangerDetected) {
        alertBox.innerHTML = dangerText;
        alertBox.style.display = "block";
      } else {
        alertBox.style.display = "none";
      }
    });

    (function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
      labelRenderer.render(scene, camera);
    })();
  </script>
</body>

</html>
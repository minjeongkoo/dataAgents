<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>SICK LiDAR 3D Visualization</title>
  <style>
    html, body { margin: 0; overflow: hidden; width: 100%; height: 100%; background: #000 }
    canvas { display: block }
  </style>

  <!-- import-map to resolve “three” bare specifier -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js"
    }
  }
  </script>
</head>
<body>
  <script src="/socket.io/socket.io.js"></script>

  <script type="module">
    import * as THREE from 'three'
    import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/controls/OrbitControls.js'

    // — Scene / Camera / Renderer —
    const scene    = new THREE.Scene()
    const camera   = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 100)
    camera.position.set(0, 0, 5)
    const renderer = new THREE.WebGLRenderer({ antialias: true })
    renderer.setSize(innerWidth, innerHeight)
    document.body.appendChild(renderer.domElement)

    // — Controls —
    const controls = new OrbitControls(camera, renderer.domElement)
    controls.enableDamping = true

    // — Geometry + Material (empty at start) —
    const geom = new THREE.BufferGeometry()
    const mat  = new THREE.PointsMaterial({ size: 0.02, color: 0x00ff00 })
    const cloud = new THREE.Points(geom, mat)
    scene.add(cloud)

    // this will hold all x,y,z in one flat array
    let allPositions = []

    function updateCloud() {
      const positions = new Float32Array(allPositions)
      geom.setAttribute('position', new THREE.BufferAttribute(positions, 3))
      geom.attributes.position.needsUpdate = true
      geom.computeBoundingSphere()
    }

    // — Animate —
    function animate() {
      requestAnimationFrame(animate)
      controls.update()
      renderer.render(scene, camera)
    }
    animate()

    // — Socket.IO: accumulate every slice —
    const socket = io()
    socket.on('lidar-points', pts => {
      if (!Array.isArray(pts) || !pts.length) return

      // append x,y,z of every incoming point
      for (const p of pts) {
        // guard against any NaNs
        if (Number.isFinite(p.x) &&
            Number.isFinite(p.y) &&
            Number.isFinite(p.z)) {
          allPositions.push(p.x, p.y, p.z)
        }
      }

      updateCloud()
    })

    // — Handle resize —
    window.addEventListener('resize', () => {
      camera.aspect = innerWidth/innerHeight
      camera.updateProjectionMatrix()
      renderer.setSize(innerWidth, innerHeight)
    })
  </script>
</body>
</html>

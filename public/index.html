<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <title>LiDAR Viewer with Layer Colors & Free View</title>
  <style>
    body { margin:0; overflow:hidden; background:#000; }
    canvas { display:block; }
  </style>
</head>
<body>
  <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.152.2/build/three.module.js",
        "three/examples/jsm/controls/OrbitControls": "https://unpkg.com/three@0.152.2/examples/jsm/controls/OrbitControls.js"
      }
    }
  </script>
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';

    // 1) Scene / Camera / Renderer
    const scene    = new THREE.Scene();
    const camera   = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 100);
    camera.position.set(0, 0, 5);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(innerWidth, innerHeight);
    document.body.appendChild(renderer.domElement);

    // 2) OrbitControls (마우스 드래그로 자유 시점)
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // 3) 포인트 클라우드용 버퍼: position + color
    const MAX_POINTS = 1000000;
    const positions  = new Float32Array(MAX_POINTS * 3);
    const colors     = new Float32Array(MAX_POINTS * 3);
    const geometry   = new THREE.BufferGeometry();
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color',    new THREE.BufferAttribute(colors,    3));
    const material = new THREE.PointsMaterial({ size: 0.02, vertexColors: true });
    const pointCloud = new THREE.Points(geometry, material);
    scene.add(pointCloud);

    const colorTmp = new THREE.Color();

    // 4) 360° 완주용 세그먼트 누적
    const SEGMENTS_PER_FRAME = 6;
    let segmentCount  = 0;
    let framePoints   = [];

    // 5) WebSocket 연결
    const ws = new WebSocket(`ws://${location.host}`);
    ws.onopen    = () => console.log('WS opened');
    ws.onerror   = e => console.error('WS error', e);
    ws.onmessage = ({ data }) => {
      const pts = JSON.parse(data);
      framePoints.push(...pts);
      segmentCount++;
      if (segmentCount >= SEGMENTS_PER_FRAME) {
        updatePointCloud(framePoints);
        framePoints   = [];
        segmentCount  = 0;
      }
    };

    // 6) 포인트 클라우드 업데이트
    function updatePointCloud(arr) {
      const maxLayer = arr.reduce((m,p) => p.layer > m ? p.layer : m, 0);
      const layerCount = maxLayer + 1;
      const len = Math.min(arr.length, MAX_POINTS);

      for (let i = 0; i < len; i++) {
        const p = arr[i];
        positions[i*3]   = p.x;
        positions[i*3+1] = p.y;
        positions[i*3+2] = p.z;

        // 레이어별 HSL → RGB 매핑
        const h = layerCount>1 ? p.layer / (layerCount - 1) : 0;
        colorTmp.setHSL(h, 1.0, 0.5);
        colors[i*3]   = colorTmp.r;
        colors[i*3+1] = colorTmp.g;
        colors[i*3+2] = colorTmp.b;
      }

      geometry.setDrawRange(0, len);
      geometry.attributes.position.needsUpdate = true;
      geometry.attributes.color.needsUpdate    = true;
    }

    // 7) 렌더 루프 & 리사이즈
    (function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    })();
    window.addEventListener('resize', () => {
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });
  </script>
</body>
</html>

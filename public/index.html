<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="UTF-8" />
  <title>LiDAR 360° Cluster Viewer</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }

    canvas {
      display: block;
    }

    .label {
      font-family: sans-serif;
      font-size: 12px;
      background: rgba(0, 0, 0, 0.6);
      color: white;
      padding: 2px 4px;
      border-radius: 2px;
      white-space: nowrap;
    }
  </style>
</head>

<body>
  <script type="module">
    // Three.js CDN
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js';
    // CSS2DRenderer (레이블 표시용)
    import { CSS2DRenderer, CSS2DObject }
      from 'https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/renderers/CSS2DRenderer.js';

    const WS_URL = `ws://${location.host}/ws`;

    // 퍼포먼스 튜닝: 한 프레임당 최대 표시할 포인트 수
    const MAX_DISPLAY_POINTS = 15000;

    let MAX_POINTS = 0;
    let positions = new Float32Array(0);
    let colors = new Float32Array(0);

    const clusterColorMap = new Map();
    const prevCenters = new Map();
    let lastFrameTime = performance.now();

    // Three.js 세팅
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 5);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(innerWidth, innerHeight);
    document.body.appendChild(renderer.domElement);

    // CSS2DRenderer for labels
    const labelRenderer = new CSS2DRenderer();
    labelRenderer.setSize(innerWidth, innerHeight);
    labelRenderer.domElement.style.position = 'absolute';
    labelRenderer.domElement.style.top = '0';
    document.body.appendChild(labelRenderer.domElement);

    // 포인트 메쉬
    let geometry = new THREE.BufferGeometry();
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    geometry.setDrawRange(0, 0);
    const material = new THREE.PointsMaterial({ size: 0.03, vertexColors: true });
    const pointsMesh = new THREE.Points(geometry, material);
    scene.add(pointsMesh);

    // 클러스터 박스·레이블·화살표 그룹
    const clusterGroup = new THREE.Group();
    scene.add(clusterGroup);

    // 리사이즈 처리
    window.addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
      labelRenderer.setSize(innerWidth, innerHeight);
    });

    // WebSocket 연결
    const socket = new WebSocket(WS_URL);
    socket.addEventListener('open', () => console.log('WS connected'));
    socket.addEventListener('close', () => console.log('WS disconnected'));
    socket.addEventListener('message', ({ data }) => {
      const pts = JSON.parse(data);
      const rawCount = pts.length;
      if (rawCount === 0) return;

      // 샘플링(다운샘플링)
      const skip = rawCount > MAX_DISPLAY_POINTS ? Math.ceil(rawCount / MAX_DISPLAY_POINTS) : 1;
      const count = Math.ceil(rawCount / skip);

      // 버퍼 재할당
      if (count > MAX_POINTS) {
        MAX_POINTS = count;
        positions = new Float32Array(MAX_POINTS * 3);
        colors = new Float32Array(MAX_POINTS * 3);
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3).setUsage(THREE.DynamicDrawUsage));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3).setUsage(THREE.DynamicDrawUsage));
      }

      // 클러스터별 포인트 모음
      const clusterPtsMap = new Map();

      // 포인트 및 색상 채우기
      let displayIndex = 0;
      for (let i = 0; i < rawCount; i += skip) {
        const p = pts[i];
        const { x, y, z, cluster_id: cid } = p;

        positions[3 * displayIndex] = x;
        positions[3 * displayIndex + 1] = y;
        positions[3 * displayIndex + 2] = z;

        // 클러스터색 생성/조회
        if (!clusterColorMap.has(cid)) {
          const hue = (cid * 0.618033988749895) % 1; // 황금비 기반 분산
          clusterColorMap.set(cid, new THREE.Color().setHSL(hue, 0.7, 0.5));
        }
        const col = clusterColorMap.get(cid);
        colors[3 * displayIndex] = col.r;
        colors[3 * displayIndex + 1] = col.g;
        colors[3 * displayIndex + 2] = col.b;

        // 그룹화
        if (!clusterPtsMap.has(cid)) clusterPtsMap.set(cid, []);
        clusterPtsMap.get(cid).push(new THREE.Vector3(x, y, z));

        displayIndex++;
      }

      // 메쉬 업데이트
      geometry.setDrawRange(0, displayIndex);
      geometry.attributes.position.needsUpdate = true;
      geometry.attributes.color.needsUpdate = true;

      // 클러스터 박스/레이블/화살표 갱신
      clusterGroup.clear();
      const now = performance.now();
      const dt = (now - lastFrameTime) / 1000; // 초 단위
      lastFrameTime = now;

      clusterPtsMap.forEach((ptsArr, cid) => {
        // 바운딩 박스
        const box3 = new THREE.Box3().setFromPoints(ptsArr);
        const helper = new THREE.Box3Helper(box3, clusterColorMap.get(cid));
        clusterGroup.add(helper);

        // 중심점
        const center = box3.getCenter(new THREE.Vector3());

        // 이전 중심
        const prev = prevCenters.get(cid);
        let velocity = new THREE.Vector3(0, 0, 0), speed = 0;
        if (prev) {
          velocity = center.clone().sub(prev.center).divideScalar(dt);
          speed = velocity.length();
        }
        prevCenters.set(cid, { center, time: now });

        // 방향 화살표
        if (speed > 0.001) {
          const dir = velocity.clone().normalize();
          const arrow = new THREE.ArrowHelper(dir, center, speed * 0.5, clusterColorMap.get(cid));
          clusterGroup.add(arrow);
        }

        // 레이블
        const div = document.createElement('div');
        div.className = 'label';
        div.textContent = `ID:${cid} ${speed.toFixed(2)} m/s`;
        const label = new CSS2DObject(div);
        label.position.copy(center);
        clusterGroup.add(label);
      });
    });

    (function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
      labelRenderer.render(scene, camera);
    })();
  </script>
</body>

</html>